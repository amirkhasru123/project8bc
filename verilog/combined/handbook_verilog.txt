Most of the codes in Verilog must be inside of modules.
	module module_name(port_lists);
	endmodule

Port_lists can be empty.
	module module_name;
	endmodule

Every line is terminated with seicolon.
	module module_name(port_lists); //a semicolon
	endmodule

Comment can be written in two ways.
	//single line comments  
	/*multiple
	lines
	comments
	*/

Multiple line comments can't be nested.
	/*
		/*
			Not possile
		*/
	*/

Single line comments can be double slashed multiple times.	//This is a comment.
	////This is the same comment.
	////////This is also the same comment.

White spaces (spaces, tabs, newlines, formfeed) are ignored.All the following lines are same.
	$display("amir");
	  $display("amir");
   		  $display("amir");

		  $display("amir");

Formfeed is slash f. It indicates printer output.
	$display("\famir");

We need to store contents in containers. Like contents, like containers.
	contents = data
	containers = identifiers

Containers and contents must have the same size.
	reg [4*8:1] name = "amir"; //in UNIX, each character is of one byte. "amir" is content and name is container. Size of amir = size of name.
	

To show the contents we must specify it's nature. string -> %s, time -> %t, real -> %f. For integers, specification depends on base.

Number format: [size]'[base_format][number]. 
	base_format
		b = binary
		d = decimal
		o = octal
		h = hexadecimal
	%b = binary, %d = decimal, %o = octal, %h = hexadecimal

Negative number will have a - sign before size.

Baseless numbers are decimals. Sizeless numbers match size from data.

There are many keywords in verilog:	always, and, assign, automatic, begin, buf, bufif0, bufif1, case, casex, casez, cell, cmos, config, deassign, default, defparam, design, disable, edge, else, end, endcase, endconfig, endfunction, endgenerate, endmodule, endprimitive, endspecify, endtable, endtask, event, for, force, forever, fork, function, generate, genvar, if, ifnone, incdir, include, initial, inout, input, instance, integer, join, large, liblist, library, localparam, macromodule, medium, module, nand, negedge, nmos, nor, not, notif0, notif1, or, output, parameter, pmos, posedge, primitive, pull0, pull1, pulldown, pullup, pulsestyle_onevent, pulsestyle_ondetect, rcmos, real, realtime, reg, release, repeat, rnmos, rpmos, rtran, rtranif0, rtranif1, scalared, small, specify, specparam, strong0, strong1, supply0, supply1, table, task, time, tran, tranif0, tranif1, tri, tri0, tri1, triand, trior, trireg, use, uwire, vectored, wait, wand, weak0, weak1, while, wire, wor, xnor, xor

We store data to perform some operation on them. We have three types of operatos.

Nets are here: 	
	wire = multiple driver issue 
	uwire = single driver ensured 

	tri = multiple drivers, default = z, conflict = x 

	wor = multiple drivers ored together
	wand = multiple drivers anded together 

	trior = tri, but conflict = ored together 
	triand = tri, but conflict = anded together
	tri0 = tri, default = 0 
	tri1 = tri, default = 1 


	supply0 = ground, constant
	supply1 = voltage reference to ground, constant

	trireg = not supported by iverilog

Variable types: 
	reg
	integer
	time 
	real
	realtime

Scalar & Vector:
	1 bit net
	Multiple bit net is vector

	We can perform operation directly to a bit
	[a:b] can be used to part select

Verilog Array
	An array declaration of a net or variable can be either scalar or vector.
	Like multidimensional arry in C.
	Arrays are allowed in Verilog for reg, wire, integer and real data types.

	Net strength
	assign  (strength1, strength0) net = expression;
	supply1, supply0, strong1, strong0, weak1, weak0, pull0, pull1, highz0, highz1
	1 = true/up
	0 = false/down


Operators
	Unary = left side operators
	+, -, !, ~, &, |, ^, ~&, ~|, ~^, ^~
	Binary = in between operators 
	+, -, *, /, %, **, ==, !=, ===, !==, >, >=, <, <=, &&, ||, &, |, ^, ^~, ~^, <<, >>, <<<, >>>
	Conditional = 3 parts operators
	condition ? one : two;

$display("text")
	Displays texts with a return.

$write("text")
	Displays texts wtihout a return.

$finish
	finish the command
